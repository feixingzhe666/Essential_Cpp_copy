/*撰写表达式
内建数据型别都可用一组运算符，包括算数、相对关联、逻辑、复合赋值，各种算数运算符中，除了“整数除法”以及“余数除法”外，并无出奇之处：
两个整数相除会产生另一个整数。小数点之后的部分会被完全舍弃：
也就是说，并没有四舍五入，
如果想要取得除法运算的余数部分，可以使用%运算符：

什么时机下，我们会运用“模运算”呢？
假设我们希望打印的数据每行不超过8个字符串：
尚未满8个字符串时，就在字符串之后印出一个空格符。
如果已满8个字符串，就在字符串之后输出换行字符，以下是实现办法：
    const int line_size =8;
    int cnt = 1;
    //一下内容被我执行多次，每次a_stringg的内容都不相同；没次执行完后，cnt的值都会加1.
    cout <<a_string
        <<(cnt % line_size ? ' ' : '\n')
其中紧接在output运算符（<<）之后，以括号括住的表达式，是所谓的条件运算符。如果模运算的结果为零，则条件运算的结果为'\n';
如果余数运算的结果非零，则条件运算的结果为''.
让我们看看这是什么意思
下面这个表达式：
    cnt % line_size
cnt恰为line_size的整数倍，运算结果为零，反之则为非零。条件运算符的一般形式如下：
    expr
    ?如果expr为true,就执行这里
    :如果expr为false,则执行这里
如果expr的运算结果为true,那么紧接在'?'之后的表达式会被执行。如果expr的运算结果为false，那么':'之后的表达式会被执行。
在我们的程序中会导致喂给output运算符一个''或是一个'\n'

条件式的值如果为0，会被视为false，其他非零值一律被视为true.此例中的cnt若非8的整数倍，条件式的值便不是0，
于是条件运算符中的'?'之后的部分就会被核定为结果

复合赋值运算符是一种便利的记号。当我们在对象身上施行某个运算符，然后将结果重新赋给该对象时，我们可能会这样写：
    cnt = cnt + 2;
但是C++程序员会这样写：
    cnt +=2;
符合赋值运算符可以和每个算数运算符结合，形成+=,-=,*=,/=和%=
欲使对象值递增或递减，C++程序员会使用递增运算符和递减运算符：
    cnt++;  //cnt的值累加1
    cnt--;  //cnt的值累减1
递增运算符和递减运算符都有前置和后置两种形式。前置式中，原值先递增（或递减）之后才被拿来使用：
    int tries = 0;
    cout <<"Are you ready for try#"
        <<++tries<<"?\n";
上例中的tries被印出来之前才进行递增运算，至于后置式写法，对象原值会先提供给表达式进行运算，然后才递增（或递减）：
    int tries = 1;
    cout<<"Are you ready for try #"
        <<tries++<<"?\n";
上例中tries被印出来之后才进行递增运算.以上两例的打印结果皆为1

任何一个关系运算符的核定结果不是true就是false。
我们可以利用相等运算符来检验用户的回答
    bool usr_more = true;
    char usr_rsp;

    //询问用户是否愿意继续下一个问题
    //将用户的回答读入usr_rsp中
    if(usr_rsp == 'N')
        usr_more = false;
    
if语句之后的表达式运算结果为true时，条件成立，于是紧接其后的语句便会被执行。
此例中如果usr_rsp等于'N'
则usr_rsp会被设为false.
反之如果urs_rsp不等于'N'
那就什么事业不会发生。
不等运算符的逻辑恰恰相反，例如：
    if(usr_rsp !='Y')
        usr_more = false;
麻烦的是，程序只检验usr_rsp的值是否为'N',而用户缺课输入小写的'n'
因此，我们必须能够识别两者。
解决方法之一就是加上else字句：
    if(usr_rsp=='N')
        usr_more = false;
    else
    if(usr_rsp == 'n')
        usr_more = false;
如果usr_rsp之值为'N',usr_more将被设为false,并结束整个if语句。
如果其值不等于'N'
那么便开始评估接下来的else子句。
换句话说，当usr_rsp等于'n'时，
usr_more也会被设成false.
如果两个条件都不符合，usr_more不会被赋给任何值

OR逻辑运算符（||）提供了上述问题的另一个解法，让我们得以同时检验多个表达式的结果：
if(usr_rsp == 'N'||usr_rsp == 'n')
    usr_more = false;
只需左右两个表达式中的一个为true OR逻辑运算符的评估结果变为true。
左侧表达式会优先被评估，如果其值为true,剩下的一个表达式就不许再被评估
本例之中，只有当usr_rsp不等于'N'时，才会再检验其值是否为'n'

AND逻辑运算符（&&）在左右两个表达式的结果皆为true时，其评估结果方为true。













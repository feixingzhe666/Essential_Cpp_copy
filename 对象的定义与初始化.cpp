/*对象的定义与初始化
我要显示某数列中的两个数字，然后要求用户回答下一个数字为何。
例如：
The value 2,3 for two consecutive elements of a numercial sequence.
What is the next value?
这两个数字事实上是“费氏数列”中的第三和第四个元素。费式数列的前数个值分别为：1,1,2,3,5,8,13...
费氏数列的最前两个数设定为1，接下来的每个数值都是前两个数值的总和
如果用户输入5，我们就印出信息，恭喜他答对，并询问他是否愿意试试另一个数列。
如果用户输入不正确的值，我们就询问他是否愿意再试一次
未来提升程序的趣味性，我们将用户答对的次数除以其回答的总次数，以此作为评量标准
这样一来，我们的程序至少需要5个对象：一个string对象用来记录用户的名字
3个整数对象分别储存用户回答的数值，用户回答的次数，以及用户答对的次数；
此外还需一个浮点数，记录用户得到的评分
为了定义对象，我们必须为它命名，并赋予它数据型别。
对象名称可以是任何字母、数字下划线的组合
大小写字母是有所区分的
对象命名不能以数字为首，当然，任何命名不能和程序本身的关键字雷同

每个对象都隶属某个特定的数据型别。对象名称如果设计的好，可以让我们直接联想该对象的属性。
数据型别决定了对象所能含有的数值范围，同时也决定了对象应该占有多少内存空间

所谓class，便是程序员自行定义的数据型别。
除此之外，C++还提供了一组内建的数据型别，包括布尔值、整型、浮点数、字符。
每一个内建数据型别都有一个相应的关键字，让我们来指定该型别。
例如，为了存储用户键入的值，我们定义了一个整数对象：
    int usr_val;
int 是C++的关键字，此处用来只是usr_val是一个整数对象。用户的“回答次数”以及“总共回答次数”也都是整数，唯一的差别是，我们希望这两个对象设定初值为0.
下面这两行可以办到：
    int num_tries = 0;
    int num_right = 0;
在单一声明语句中一并定义多个对象，其间以逗号区隔，也可以是：
    int num_tries = 0,num_right = 0;
一般来说，将每个对象初始化是个好主意——即使初值只用来表示该对象尚未具有真正意义的值，
我之所以不为usr_val设初值，是因为其值必须直接根据用户的输入加以设定，然后程序才能用之。

另外还有一种不同的初始化语法，称为构造函数语法：
    int num_tries(0);

“以assignment运算符（=）进行初始化”这个操作系衍袭C语言而来，如果对象属于内建型别，或者对象可以单一值加以初始化，这种方式就没有问题。例如以下的string class:
    string sequence_name = "Fibonacci":
但是如果对象需要多个初始值，这种方式就没有办法完成任务了。以标准程序库中的复数为例，它就需要两个初始值，一为实部，一为虚部
以下便是用来处理“多值初始化”的构造函数初始化语法。
    #include<complex>
    complex<double>purei(0,7);
出现于complex之后的尖括号，表示complex是一个template class（模板类）
template允许我们在“不必指明data members之型别”的情况下定义class

举个例子：复数类内含两个member data object
其一表示复数的实数部分，其二表示虚数部分，两者都需要以浮点数来表现，但我们应该采用哪一种浮点数型别呢？
C++支持3中浮点数型别，分别是以关键字float表示的单精度浮点数，以关键字double表示的双精度浮点数以及连续两个关键字long double表示的扩充精度浮点数。

template class机制使程序员得以制导使用template class时才决定真正的数据型别。程序员可以先安插一个代名，稍后才绑定至实际的数据型别。
上例便是将complex类成员绑定至double型别

用户获得的评分可能是某个比值，所以我们必须以浮点数来表示。
我以double型别定义之：
    double usr_score = 0.0;

当我们询问“再试一次？”以及“你是否愿意回答其他类型的数列问题？”时，我们还必须将用户的回答（yes或no）记录下来
这个时候使用字符(char)对象就绰绰有余了：
    char usr_more;
    cout <<"Try another sequence? Y/N";
    cin >> usr_more;
关键字char表示字符型别。单引号括住的字符代表所谓的字面常量。
此外尚有一些特别的内建字符常量，例如：
'\n'换行字符
'\t'跳格字符
'\0'null
'\''单引号
'\"'双引号
'\\'反斜线
举个例子，我们想在打印用户姓名之前，先换行并跳一个定位距离，下面这行可以办到：
    cout<<'\n'<<'\t'<<user_name;
另一种写法是将两个不同的字符合并成一个字符串：
    cout<<"\n\t"<<user_name:
我们常常会在字面常量中使用这些特殊字符，例如
在Windows操作系统下以常量字符串表示文件路径时，必须以“转义字符”表示反斜线字符：
    "F:\\essential\\programs\\chapter1\\ch1_main.cpp":

C++提供内建的Boolean型别，用以表示真假值，我们的程序中可以定义Boolean对象来控制是否要显示下一组数列：
    bool go_for_it =true;
Boolean对象系由关键字bool指出，其值可谓true或false
截至目前我们所定义出来的对象，其值都会在程序执行过程中改变。
例如go_for_it最后会被设成false,用户每次猜完数字之后，usr_score的值也可能更动。

但有时候我们需要一些用来表示常量值的对象：比如用户最多课猜多少次，或者像圆周率这类永恒不变的值。
此等对象的内容在程序执行过程中不应该有所更动。我们应当如何避免无意间更懂此类对象的值呢？
C++的const关键字可以排上用场：
    const int_max_tries = 3;
    const double pi = 3.14159;
被定义为const的对象，在获得初值之后，无法再有任何变动。如果你企图为const对象指定新值，会产生编译器错误。
例如：
    max_tries = 42; //错误：这是个const对象










